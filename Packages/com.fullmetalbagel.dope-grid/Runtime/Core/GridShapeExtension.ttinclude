<#+
    void MakeExtensionForReadOnlyGridShape(params (string shapeType, string cellValueType)[] shapes)
    {
#>
public static partial class ReadOnlyGridShapeExtension
{
    <#+
    foreach (var (shapeType, cellValueType) in shapes)
    {
        // Extract ref/in modifier from shapeType
        var modifier = "";
        var typeName = shapeType;
        if (shapeType.StartsWith("ref "))
        {
            modifier = "ref ";
            typeName = shapeType.Substring(4);
        }
        else if (shapeType.StartsWith("in "))
        {
            modifier = "in ";
            typeName = shapeType.Substring(3);
        }

        var isGeneric = cellValueType.StartsWith("T");
        var cellTypeParam = isGeneric ? cellValueType.Split(' ')[0] : cellValueType;
        var typeConstraint = isGeneric && cellValueType.Contains(" where ") ? " " + cellValueType.Substring(cellValueType.IndexOf("where ")) : "";
        var genericConstraint = isGeneric ? $"<{cellTypeParam}>" : "";
    #>

#region <#= shapeType #>

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int GetIndex<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, GridPosition pos)<#= typeConstraint #> => GetIndex(<#= modifier.Trim() #> shape, pos.X, pos.Y);

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int GetIndex<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, int x, int y)<#= typeConstraint #> => y * shape.Width + x;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static <#= cellTypeParam #> GetCellValue<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, GridPosition pos)<#= typeConstraint #> => shape[pos];

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static <#= cellTypeParam #> GetCellValue<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, int x, int y)<#= typeConstraint #> => GetCellValue(<#= modifier.Trim() #> shape, new GridPosition(x, y));

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int Size<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape)<#= typeConstraint #> => shape.Width * shape.Height;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool IsEmpty<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape)<#= typeConstraint #> => shape.Width <= 0 || shape.Height <= 0;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Contains<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, GridPosition pos)<#= typeConstraint #> => Contains(<#= modifier.Trim() #> shape, pos.X, pos.Y);

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Contains<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, int x, int y)<#= typeConstraint #> => x >= 0 && x < shape.Width && y >= 0 && y < shape.Height;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int CountValue<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, <#= cellTypeParam #> target)<#= typeConstraint #>
    {
        return Count(<#= modifier.Trim() #> shape, (v, t) => System.Collections.Generic.EqualityComparer<<#= cellTypeParam #>>.Default.Equals(v, t), target);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int CountWhere<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, System.Func<<#= cellTypeParam #>, bool> predicate)<#= typeConstraint #>
    {
        return Count(<#= modifier.Trim() #> shape, (value, p) => p(value), predicate);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int Count<#= isGeneric ? $"<{cellTypeParam}, TCaptureData>" : "<TCaptureData>" #>(this <#= modifier #><#= typeName #> shape, System.Func<<#= cellTypeParam #>, TCaptureData, bool> predicate, TCaptureData data)<#= typeConstraint #>
    {
        int count = 0;
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
        {
            if (predicate(shape[i], data))
                count++;
        }
        return count;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Any<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, System.Func<<#= cellTypeParam #>, bool> predicate)<#= typeConstraint #>
    {
        return Any(<#= modifier.Trim() #> shape, (v, p) => p(v), predicate);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Any<#= isGeneric ? $"<{cellTypeParam}, TCaptureData>" : "<TCaptureData>" #>(this <#= modifier #><#= typeName #> shape, System.Func<<#= cellTypeParam #>, TCaptureData, bool> predicate, TCaptureData data)<#= typeConstraint #>
    {
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
        {
            if (predicate(shape[i], data))
                return true;
        }
        return false;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool All<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, System.Func<<#= cellTypeParam #>, bool> predicate)<#= typeConstraint #>
    {
        return All(<#= modifier.Trim() #> shape, (v, p) => p(v), predicate);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool All<#= isGeneric ? $"<{cellTypeParam}, TCaptureData>" : "<TCaptureData>" #>(this <#= modifier #><#= typeName #> shape, System.Func<<#= cellTypeParam #>, TCaptureData, bool> predicate, TCaptureData data)<#= typeConstraint #>
    {
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
        {
            if (!predicate(shape[i], data))
                return false;
        }
        return true;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool IsTrimmed<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        // Empty shapes are considered trimmed
        if (shape.Width == 0 || shape.Height == 0)
            return true;

        // A shape is trimmed when all four borders have at least one occupied cell
        return HasOccupiedCellInRow(<#= modifier.Trim() #> shape, 0, freeValue) &&                    // Top row
               HasOccupiedCellInRow(<#= modifier.Trim() #> shape, shape.Height - 1, freeValue) &&     // Bottom row
               HasOccupiedCellInColumn(<#= modifier.Trim() #> shape, 0, freeValue) &&                 // Left column
               HasOccupiedCellInColumn(<#= modifier.Trim() #> shape, shape.Width - 1, freeValue);     // Right column

        static bool HasOccupiedCellInRow(<#= modifier #><#= typeName #> shape, int row, <#= cellTypeParam #> freeValue)
        {
            for (var column = 0; column < shape.Width; column++)
            {
                var value = GetCellValue(<#= modifier.Trim() #> shape, column, row);
                var isFree = value.Equals(freeValue);
                if (!isFree) return true;
            }
            return false;
        }

        static bool HasOccupiedCellInColumn(<#= modifier #><#= typeName #> shape, int column, <#= cellTypeParam #> freeValue)
        {
            for (var row = 0; row < shape.Height; row++)
            {
                var value = GetCellValue(<#= modifier.Trim() #> shape, column, row);
                var isFree = value.Equals(freeValue);
                if (!isFree) return true;
            }
            return false;
        }
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool CanPlaceItem<#= genericConstraint #>(this <#= modifier #><#= typeName #> container, ImmutableGridShape item, GridPosition pos, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        // Bounds check
        if (pos.X < 0 || pos.Y < 0 || pos.X + item.Width > container.Width || pos.Y + item.Height > container.Height)
            return false;

        // Check each bit of the shape against the grid
        for (var sy = 0; sy < item.Height; sy++)
        for (var sx = 0; sx < item.Width; sx++)
        {
            var shapePos = new GridPosition(sx, sy);
            if (item.GetCellValue(shapePos))
            {
                var gridPos = new GridPosition(pos.X + sx, pos.Y + sy);
                if (GetCellValue(<#= modifier.Trim() #> container, gridPos).Equals(freeValue))
                    return false;
            }
        }

        return true;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static (GridPosition position, RotationDegree rotation) FindFirstFitWithFreeRotation<#= genericConstraint #>(this <#= modifier #><#= typeName #> container, ImmutableGridShape item)<#= typeConstraint #>
    {
        var rotateCount = 0;
        var rotatedItem = item;
        var position = GridPosition.Invalid;
        do
        {
            position = FindFirstFitWithFixedRotation(<#= modifier.Trim() #> container, rotatedItem);
            if (position.IsValid) break;
            rotatedItem = rotatedItem.Rotate90();
            rotateCount++;
        }
        while (rotatedItem != item);

        var rotation = rotateCount switch
        {
            0 => RotationDegree.None,
            1 => RotationDegree.Clockwise90,
            2 => RotationDegree.Clockwise180,
            3 => RotationDegree.Clockwise270,
            _ => throw new System.NotImplementedException()
        };

        return (position, rotation);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool CheckShapeCells<#= isGeneric ? $"<{cellTypeParam}, TData>" : "<TData>" #>(this <#= modifier #><#= typeName #> grid, ImmutableGridShape shape, GridPosition position, System.Func<GridPosition, <#= cellTypeParam #>, TData, bool> cellPredicate, TData data)<#= typeConstraint #>
    {
        for (int y = 0; y < shape.Height; y++)
        {
            for (int x = 0; x < shape.Width; x++)
            {
                if (shape[x, y]) // Shape cell is occupied
                {
                    var gridPos = new GridPosition(position.X + x, position.Y + y);

                    // Check bounds
                    if (!Contains(<#= modifier.Trim() #> grid, gridPos))
                        return false;

                    // Check predicate
                    if (!cellPredicate(gridPos, grid[gridPos], data))
                        return false;
                }
            }
        }

        return true;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static GridPosition FindFirstFitWithFixedRotation<#= genericConstraint #>(this <#= modifier #><#= typeName #> grid, ImmutableGridShape item, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        var maxY = grid.Height - item.Height + 1;
        var maxX = grid.Width - item.Width + 1;

        for (var y = 0; y < maxY; y++)
        for (var x = 0; x < maxX; x++)
            if (CanPlaceItem(<#= modifier.Trim() #> grid, item, new GridPosition(x, y), freeValue))
                return new GridPosition(x, y);

        return GridPosition.Invalid;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool IsWithinBounds<#= genericConstraint #>(this <#= modifier #><#= typeName #> grid, ImmutableGridShape shape, GridPosition position)<#= typeConstraint #>
    {
        return position is { X: >= 0, Y: >= 0 } &&
               position.X + shape.Width <= grid.Width &&
               position.Y + shape.Height <= grid.Height;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool IsWithinBounds<#= genericConstraint #>(this <#= modifier #><#= typeName #> grid, ImmutableGridShape shape, int x, int y)<#= typeConstraint #>
    {
        return IsWithinBounds(<#= modifier.Trim() #> grid, shape, new GridPosition(x, y));
    }

#endregion
    <#+
    }
    #>
}

<#+
    }
#>

<#+
    void MakeExtensionForWritableGridShape(params (string shapeType, string cellValueType)[] shapes)
    {
#>
public static partial class WritableGridShapeExtension
{
    <#+
    foreach (var (shapeType, cellValueType) in shapes)
    {
        // Extract ref/in modifier from shapeType
        var modifier = "";
        var typeName = shapeType;
        if (shapeType.StartsWith("ref "))
        {
            modifier = "ref ";
            typeName = shapeType.Substring(4);
        }
        else if (shapeType.StartsWith("in "))
        {
            modifier = "in ";
            typeName = shapeType.Substring(3);
        }

        var isGeneric = cellValueType.StartsWith("T");
        var cellTypeParam = isGeneric ? cellValueType.Split(' ')[0] : cellValueType;
        var typeConstraint = isGeneric && cellValueType.Contains(" where ") ? " " + cellValueType.Substring(cellValueType.IndexOf("where ")) : "";
        var genericConstraint = isGeneric ? $"<{cellTypeParam}>" : "";
    #>

#region <#= shapeType #>

    public static void SetCellValue<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, GridPosition pos, <#= cellTypeParam #> value)<#= typeConstraint #> => shape.SetCellValue(pos.X, pos.Y, value);
    public static void SetCellValue<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, int x, int y, <#= cellTypeParam #> value)<#= typeConstraint #> => shape[x, y] = value;

    public static void FillAll<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, <#= cellTypeParam #> value)<#= typeConstraint #>
    {
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
            shape[i] = value;
    }

    public static void FillRect<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, int x, int y, int width, int height, <#= cellTypeParam #> value)<#= typeConstraint #>
    {
        for (int dy = 0; dy < height; dy++)
        {
            for (int dx = 0; dx < width; dx++)
            {
                var px = x + dx;
                var py = y + dy;
                if (px >= 0 && px < shape.Width && py >= 0 && py < shape.Height)
                {
                    shape.SetCellValue(px, py, value);
                }
            }
        }
    }

    public static void FillRect<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape, GridPosition pos, int width, int height, <#= cellTypeParam #> value)<#= typeConstraint #>
    {
        FillRect(<#= modifier.Trim() #> shape, pos.X, pos.Y, width, height, value);
    }

    public static void Clear<#= genericConstraint #>(this <#= modifier #><#= typeName #> shape)<#= typeConstraint #>
    {
        FillAll(<#= modifier.Trim() #> shape, default);
    }

    public static void PlaceItem<#= genericConstraint #>(this <#= modifier #><#= typeName #> container, ImmutableGridShape item, GridPosition pos, <#= cellTypeParam #> value)<#= typeConstraint #>
    {
        for (var sy = 0; sy < item.Height; sy++)
        for (var sx = 0; sx < item.Width; sx++)
        {
            var shapePos = new GridPosition(sx, sy);
            if (item.GetCellValue(shapePos))
            {
                var gridPos = new GridPosition(pos.X + sx, pos.Y + sy);
                container.SetCellValue(gridPos, value);
            }
        }
    }

    public static void RemoveItem<#= genericConstraint #>(this <#= modifier #><#= typeName #> container, ImmutableGridShape item, GridPosition pos, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        for (var sy = 0; sy < item.Height; sy++)
        for (var sx = 0; sx < item.Width; sx++)
        {
            var shapePos = new GridPosition(sx, sy);
            if (item.GetCellValue(shapePos))
            {
                var gridPos = new GridPosition(pos.X + sx, pos.Y + sy);
                container.SetCellValue(gridPos, freeValue);
            }
        }
    }

#endregion
    <#+
    }
    #>
}

<#+
    }
#>

<#+
    void MakeExtensionForReadOnlyGridShape(params (string shapeType, string cellValueType)[] shapes)
    {
#>
public static partial class ReadOnlyGridShapeExtension
{
    <#+
    foreach (var (shapeType, cellValueType) in shapes)
    {
        var isGeneric = cellValueType.StartsWith("T");
        var cellTypeParam = isGeneric ? cellValueType.Split(' ')[0] : cellValueType;
        var typeConstraint = isGeneric && cellValueType.Contains(" where ") ? " " + cellValueType.Substring(cellValueType.IndexOf("where ")) : "";
        var genericConstraint = isGeneric ? $"<{cellTypeParam}>" : "";

        // Shape metadata
        var isReadOnly = shapeType.Contains(".ReadOnly");
        var isImmutable = shapeType.Contains("Immutable");
        var isBoolType = cellTypeParam == "bool";
    #>

#region <#= shapeType #>

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int GetIndex<#= genericConstraint #>(this in <#= shapeType #> shape, GridPosition pos)<#= typeConstraint #> => GetIndex(shape, pos.X, pos.Y);

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int GetIndex<#= genericConstraint #>(this in <#= shapeType #> shape, int x, int y)<#= typeConstraint #> => y * shape.Width + x;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static <#= cellTypeParam #> GetCellValue<#= genericConstraint #>(this in <#= shapeType #> shape, GridPosition pos)<#= typeConstraint #> => shape[pos];

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static <#= cellTypeParam #> GetCellValue<#= genericConstraint #>(this in <#= shapeType #> shape, int x, int y)<#= typeConstraint #> => GetCellValue(shape, new GridPosition(x, y));

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int Size<#= genericConstraint #>(this in <#= shapeType #> shape)<#= typeConstraint #> => shape.Width * shape.Height;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool IsEmpty<#= genericConstraint #>(this in <#= shapeType #> shape)<#= typeConstraint #> => shape.Width <= 0 || shape.Height <= 0;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Contains<#= genericConstraint #>(this in <#= shapeType #> shape, GridPosition pos)<#= typeConstraint #> => Contains(shape, pos.X, pos.Y);

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Contains<#= genericConstraint #>(this in <#= shapeType #> shape, int x, int y)<#= typeConstraint #> => x >= 0 && x < shape.Width && y >= 0 && y < shape.Height;

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int CountValue<#= genericConstraint #>(this in <#= shapeType #> shape, <#= cellTypeParam #> target)<#= typeConstraint #>
    {
        return Count(shape, (v, t) => System.Collections.Generic.EqualityComparer<<#= cellTypeParam #>>.Default.Equals(v, t), target);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int CountWhere<#= genericConstraint #>(this in <#= shapeType #> shape, System.Func<<#= cellTypeParam #>, bool> predicate)<#= typeConstraint #>
    {
        return Count(shape, (value, p) => p(value), predicate);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static int Count<#= isGeneric ? $"<{cellTypeParam}, TCaptureData>" : "<TCaptureData>" #>(this in <#= shapeType #> shape, System.Func<<#= cellTypeParam #>, TCaptureData, bool> predicate, TCaptureData data)<#= typeConstraint #>
    {
        int count = 0;
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
        {
            if (predicate(shape[i], data))
                count++;
        }
        return count;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Any<#= genericConstraint #>(this in <#= shapeType #> shape, System.Func<<#= cellTypeParam #>, bool> predicate)<#= typeConstraint #>
    {
        return Any(shape, (v, p) => p(v), predicate);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool Any<#= isGeneric ? $"<{cellTypeParam}, TCaptureData>" : "<TCaptureData>" #>(this in <#= shapeType #> shape, System.Func<<#= cellTypeParam #>, TCaptureData, bool> predicate, TCaptureData data)<#= typeConstraint #>
    {
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
        {
            if (predicate(shape[i], data))
                return true;
        }
        return false;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool All<#= genericConstraint #>(this in <#= shapeType #> shape, System.Func<<#= cellTypeParam #>, bool> predicate)<#= typeConstraint #>
    {
        return All(shape, (v, p) => p(v), predicate);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool All<#= isGeneric ? $"<{cellTypeParam}, TCaptureData>" : "<TCaptureData>" #>(this in <#= shapeType #> shape, System.Func<<#= cellTypeParam #>, TCaptureData, bool> predicate, TCaptureData data)<#= typeConstraint #>
    {
        var size = shape.Width * shape.Height;
        for (int i = 0; i < size; i++)
        {
            if (!predicate(shape[i], data))
                return false;
        }
        return true;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool IsTrimmed<#= genericConstraint #>(this in <#= shapeType #> shape, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        // Empty shapes are considered trimmed
        if (shape.Width == 0 || shape.Height == 0)
            return true;

        // A shape is trimmed when all four borders have at least one occupied cell
        return HasOccupiedCellInRow(shape, 0, freeValue) &&                    // Top row
               HasOccupiedCellInRow(shape, shape.Height - 1, freeValue) &&     // Bottom row
               HasOccupiedCellInColumn(shape, 0, freeValue) &&                 // Left column
               HasOccupiedCellInColumn(shape, shape.Width - 1, freeValue);     // Right column

        static bool HasOccupiedCellInRow(in <#= shapeType #> shape, int row, <#= cellTypeParam #> freeValue)
        {
            for (var column = 0; column < shape.Width; column++)
            {
                var value = shape.GetCellValue(column, row);
                var isFree = value.Equals(freeValue);
                if (!isFree) return true;
            }
            return false;
        }

        static bool HasOccupiedCellInColumn(in <#= shapeType #> shape, int column, <#= cellTypeParam #> freeValue)
        {
            for (var row = 0; row < shape.Height; row++)
            {
                var value = shape.GetCellValue(column, row);
                var isFree = value.Equals(freeValue);
                if (!isFree) return true;
            }
            return false;
        }
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool CanPlaceItem<#= genericConstraint #>(this in <#= shapeType #> container, ImmutableGridShape item, GridPosition pos, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        // Bounds check
        if (pos.X < 0 || pos.Y < 0 || pos.X + item.Width > container.Width || pos.Y + item.Height > container.Height)
            return false;

        // Check each bit of the shape against the grid
        for (var sy = 0; sy < item.Height; sy++)
        for (var sx = 0; sx < item.Width; sx++)
        {
            var shapePos = new GridPosition(sx, sy);
            if (item.GetCellValue(shapePos))
            {
                var gridPos = new GridPosition(pos.X + sx, pos.Y + sy);
                if (container.GetCellValue(gridPos).Equals(freeValue))
                    return false;
            }
        }

        return true;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static (GridPosition position, RotationDegree rotation) FindFirstFitWithFreeRotation<#= genericConstraint #>(this in <#= shapeType #> container, ImmutableGridShape item)<#= typeConstraint #>
    {
        var rotateCount = 0;
        var rotatedItem = item;
        var position = GridPosition.Invalid;
        do
        {
            position = FindFirstFitWithFixedRotation(container, rotatedItem);
            if (position.IsValid) break;
            rotatedItem = rotatedItem.Rotate90();
            rotateCount++;
        }
        while (rotatedItem != item);

        var rotation = rotateCount switch
        {
            0 => RotationDegree.None,
            1 => RotationDegree.Clockwise90,
            2 => RotationDegree.Clockwise180,
            3 => RotationDegree.Clockwise270,
            _ => throw new System.NotImplementedException()
        };

        return (position, rotation);
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static bool CheckShapeCells<#= isGeneric ? $"<{cellTypeParam}, TData>" : "<TData>" #>(this in <#= shapeType #> grid, ImmutableGridShape shape, GridPosition position, System.Func<GridPosition, <#= cellTypeParam #>, TData, bool> cellPredicate, TData data)<#= typeConstraint #>
    {
        for (int y = 0; y < shape.Height; y++)
        {
            for (int x = 0; x < shape.Width; x++)
            {
                if (shape[x, y]) // Shape cell is occupied
                {
                    var gridPos = new GridPosition(position.X + x, position.Y + y);

                    // Check bounds
                    if (!grid.Contains(gridPos))
                        return false;

                    // Check predicate
                    if (!cellPredicate(gridPos, grid[gridPos], data))
                        return false;
                }
            }
        }

        return true;
    }

    [JetBrains.Annotations.Pure, JetBrains.Annotations.MustUseReturnValue]
    public static GridPosition FindFirstFitWithFixedRotation<#= genericConstraint #>(this <#= shapeType #> grid, ImmutableGridShape item, <#= cellTypeParam #> freeValue = default)<#= typeConstraint #>
    {
        var maxY = grid.Height - item.Height + 1;
        var maxX = grid.Width - item.Width + 1;

        for (var y = 0; y < maxY; y++)
        for (var x = 0; x < maxX; x++)
            if (CanPlaceItem(grid, item, new GridPosition(x, y), freeValue))
                return new GridPosition(x, y);

        return GridPosition.Invalid;
    }

#endregion
    <#+
    }
    #>
}

<#+
    }
#>
